/*
 * Copyright (c) 2021 Golioth, Inc.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <logging/log.h>
LOG_MODULE_REGISTER(golioth_dfu, LOG_LEVEL_DBG);

#include <net/coap.h>
#include <net/golioth/fw.h>
#include <net/golioth/system_client.h>
#include <net/golioth/wifi.h>

#include <dfu/flash_img.h>
#include <dfu/mcuboot.h>
#include <logging/log_ctrl.h>
#include <power/reboot.h>
#include <stdlib.h>
#include <stdio.h>
#include <storage/flash_map.h>
#include <tinycbor/cbor.h>
#include <tinycbor/cbor_buf_reader.h>

#include <storage/flash_map.h>

/* FLASH_AREA_ID() values used below are auto-generated by DT */
#ifdef CONFIG_TRUSTED_EXECUTION_NONSECURE
#define FLASH_AREA_IMAGE_PRIMARY FLASH_AREA_ID(image_0_nonsecure)
#define FLASH_AREA_IMAGE_SECONDARY FLASH_AREA_ID(image_1_nonsecure)
#else
#define FLASH_AREA_IMAGE_PRIMARY FLASH_AREA_ID(image_0)
#if FLASH_AREA_LABEL_EXISTS(image_1)
#define FLASH_AREA_IMAGE_SECONDARY FLASH_AREA_ID(image_1)
#endif
#endif /* CONFIG_TRUSTED_EXECUTION_NONSECURE */

#define REBOOT_DELAY_SEC	1

static struct golioth_client *client = GOLIOTH_SYSTEM_CLIENT_GET();

static struct coap_reply coap_replies[4];

struct dfu_ctx {
	struct golioth_fw_download_ctx fw_ctx;
	struct flash_img_context flash;
};

static struct dfu_ctx update_ctx;

static char current_version_str[sizeof("255.255.65535")];

static int current_version_init(const struct device *dev)
{
	struct mcuboot_img_header hdr;
	int written;
	int err;

	err = boot_read_bank_header(FLASH_AREA_IMAGE_PRIMARY, &hdr, sizeof(hdr));
	if (err) {
		LOG_ERR("Failed to read primary area (%u) header: %d",
			FLASH_AREA_IMAGE_PRIMARY, err);
		return err;
	}

	written = snprintf(current_version_str, sizeof(current_version_str),
			   "%u.%u.%u",
			   (unsigned int) hdr.h.v1.sem_ver.major,
			   (unsigned int) hdr.h.v1.sem_ver.minor,
			   (unsigned int) hdr.h.v1.sem_ver.revision);
	if (written >= sizeof(current_version_str)) {
		LOG_ERR("Version string is too long!");
		current_version_str[0] = '\0';
		return -ENOMEM;
	}

	return 0;
}

SYS_INIT(current_version_init, APPLICATION, CONFIG_APPLICATION_INIT_PRIORITY);

/**
 * Determines if the specified area of flash is completely unwritten.
 *
 * @note This is a copy of zephyr_img_mgmt_flash_check_empty() from mcumgr.
 */
static int flash_area_check_empty(const struct flash_area *fa,
				  bool *out_empty)
{
	uint32_t data[16];
	off_t addr;
	off_t end;
	int bytes_to_read;
	int rc;
	int i;

	__ASSERT_NO_MSG(fa->fa_size % 4 == 0);

	end = fa->fa_size;
	for (addr = 0; addr < end; addr += sizeof(data)) {
		if (end - addr < sizeof(data)) {
			bytes_to_read = end - addr;
		} else {
			bytes_to_read = sizeof(data);
		}

		rc = flash_area_read(fa, addr, data, bytes_to_read);
		if (rc != 0) {
			flash_area_close(fa);
			return rc;
		}

		for (i = 0; i < bytes_to_read / 4; i++) {
			if (data[i] != 0xffffffff) {
				*out_empty = false;
				flash_area_close(fa);
				return 0;
			}
		}
	}

	*out_empty = true;

	return 0;
}

static int flash_img_erase_if_needed(struct flash_img_context *ctx)
{
	bool empty;
	int err;

	if (IS_ENABLED(CONFIG_IMG_ERASE_PROGRESSIVELY)) {
		return 0;
	}

	err = flash_area_check_empty(ctx->flash_area, &empty);
	if (err) {
		return err;
	}

	if (empty) {
		return 0;
	}

	err = flash_area_erase(ctx->flash_area, 0, ctx->flash_area->fa_size);
	if (err) {
		return err;
	}

	return 0;
}

static const char *swap_type_str(int swap_type)
{
	switch (swap_type) {
	case BOOT_SWAP_TYPE_NONE:
		return "none";
	case BOOT_SWAP_TYPE_TEST:
		return "test";
	case BOOT_SWAP_TYPE_PERM:
		return "perm";
	case BOOT_SWAP_TYPE_REVERT:
		return "revert";
	case BOOT_SWAP_TYPE_FAIL:
		return "fail";
	}

	return "unknown";
}

static int flash_img_prepare(struct flash_img_context *flash)
{
	int swap_type;
	int err;

	swap_type = mcuboot_swap_type();
	switch (swap_type) {
	case BOOT_SWAP_TYPE_REVERT:
		LOG_WRN("'revert' swap type detected, it is not safe to continue");
		return -EBUSY;
	default:
		LOG_INF("swap type: %s", swap_type_str(swap_type));
		break;
	}

	err = flash_img_init(flash);
	if (err) {
		LOG_ERR("failed to init: %d", err);
		return err;
	}

	err = flash_img_erase_if_needed(flash);
	if (err) {
		LOG_ERR("failed to erase: %d", err);
		return err;
	}

	return 0;
}

static int data_received(struct golioth_blockwise_download_ctx *ctx,
			 const uint8_t *data, size_t offset, size_t len,
			 bool last)
{
	struct dfu_ctx *dfu = CONTAINER_OF(ctx, struct dfu_ctx, fw_ctx);
	int err;

	LOG_DBG("Received %zu bytes at offset %zu%s", len, offset,
		last ? " (last)" : "");

	if (offset == 0) {
		err = flash_img_prepare(&dfu->flash);
		if (err) {
			return err;
		}
	}

	err = flash_img_buffered_write(&dfu->flash, data, len, last);
	if (err) {
		LOG_ERR("Failed to write to flash: %d", err);
		return err;
	}

	if (offset > 0 && last) {
		LOG_INF("Requesting upgrade");

		err = boot_request_upgrade(BOOT_UPGRADE_TEST);
		if (err) {
			LOG_ERR("Failed to request upgrade: %d", err);
			return err;
		}

		LOG_INF("Rebooting in %d second(s)", REBOOT_DELAY_SEC);

		/* Synchronize logs */
		LOG_PANIC();

		k_sleep(K_SECONDS(REBOOT_DELAY_SEC));

		sys_reboot(SYS_REBOOT_COLD);
	}

	return 0;
}

static int golioth_desired_update(const struct coap_packet *update,
				  struct coap_reply *reply,
				  const struct sockaddr *from)
{
	struct coap_reply *fw_reply;
	const uint8_t *payload;
	uint16_t payload_len;
	uint8_t version[64];
	size_t version_len = sizeof(version);
	int err;

	payload = coap_packet_get_payload(update, &payload_len);
	if (!payload) {
		LOG_ERR("No payload in CoAP!");
		return -EIO;
	}

	LOG_HEXDUMP_DBG(payload, payload_len, "Desired");

	err = golioth_fw_desired_parse(payload, payload_len, version,
				       &version_len);
	if (err) {
		return err;
	}

	if (!strncmp(current_version_str, version, version_len)) {
		LOG_INF("Desired version (%s) matches current firmware version!",
			log_strdup(version));
		return -EALREADY;
	}

	fw_reply = coap_reply_next_unused(coap_replies, ARRAY_SIZE(coap_replies));
	if (!reply) {
		LOG_ERR("No more reply handlers");
		return -ENOMEM;
	}

	LOG_HEXDUMP_INF(version, version_len, "Requesting firmware with version");

	err = golioth_fw_download(client, &update_ctx.fw_ctx, version, version_len,
				  fw_reply, data_received);
	if (err) {
		LOG_ERR("Failed to request firmware: %d", err);
		return err;
	}

	return 0;
}

static void golioth_on_connect(struct golioth_client *client)
{
	struct coap_reply *reply;
	int err;
	int i;

	if (current_version_str[0] == '\0') {
		LOG_ERR("Version string is empty!");
		return;
	}

	for (i = 0; i < ARRAY_SIZE(coap_replies); i++) {
		coap_reply_clear(&coap_replies[i]);
	}

	reply = coap_reply_next_unused(coap_replies, ARRAY_SIZE(coap_replies));
	if (!reply) {
		LOG_ERR("No more reply handlers");
	}

	err = golioth_fw_observe_desired(client, current_version_str, reply,
					 golioth_desired_update);
	if (err) {
		coap_reply_clear(reply);
	}
}

static void golioth_on_message(struct golioth_client *client,
			       struct coap_packet *rx)
{
	uint16_t payload_len;
	const uint8_t *payload;
	uint8_t type;

	type = coap_header_get_type(rx);
	payload = coap_packet_get_payload(rx, &payload_len);

	(void)coap_response_received(rx, NULL, coap_replies,
				     ARRAY_SIZE(coap_replies));
}

void main(void)
{
	int err;

	LOG_DBG("Start DFU sample");

	err = boot_write_img_confirmed();
	if (err) {
		LOG_ERR("Failed to confirm image: %d", err);
	}

	if (IS_ENABLED(CONFIG_GOLIOTH_SAMPLE_WIFI)) {
		LOG_INF("Connecting to WiFi");
		wifi_connect();
	}

	client->on_connect = golioth_on_connect;
	client->on_message = golioth_on_message;
	golioth_system_client_start();
}
